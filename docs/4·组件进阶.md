# 4·组件进阶



## 组件通讯

组件是独立且封闭的单元，默认情况下，只能使用自己的数据。在组件化过程中，要将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而多个组件之间不可避免的要共享数据，就需要打破组件的独立封闭性，这个过程就是组件通讯。

## props

组件是封闭的，props 的作用是接收传递给组件的数据，props 是只读的对象，只能读取无法修改对象的属性值。

- 传递数据：给组件标签添加属性，可以给组件传递任意类型的数据。

- 接收数据：函数组件通过参数 props 接收数据，类组件通过 `this.props` 接收数据。

```jsx
<ComponentsPlus name="lingyuan" />


// 函数组件接收数据
function ComponentsPlus(props) {  
    return (
        <div>
            hello world,接收数据：{props.name}
        </div>
    )
}

// 类组件接收数据
class ComponentsPlus extends React.Component {

    // 使用类组件时，如果使用了构造函数，应该将 props 传递给 super()，否则，无法在构造函数中获取到 props
    constructor(props) {
        // 将props传递给父类构造函数
        super(props)

        this.state = {
            name: props.name
        }
    }
        

    render() {
        return (
            <div>
                hello world <br/>
                接收数据：<br/>
                {this.props.name}<br/>
                {this.state.name}<br/>
            </div>
        )
    }
}

export default ComponentsPlus;
```

## 通讯方式

组件之间的三种通讯方式分：

1. 父组件 -> 子组件。
2. 子组件 -> 父组件。
3. 兄弟组件。

### 父组件 -> 子组件

父组件提供要传递的 state 数据，给子组件标签添加属性，值为 state 中的数据。

子组件中通过 props 接收父组件中传递的数据。

```jsx
// Parent.js
import React from "react";
import Child from "./Child"

class Parent extends React.Component {

    state = {
        name: 'lingyuan'
    }

    render() {
        return (
            <div>
                Hello, {this.state.name},this Parent.

                {/* 传递数据给子组件 */}
                <Child name={this.state.name}/>
            </div>
        )
    }
}
export default Parent

// Child.js
import React from 'react';

class Child extends React.Component {

    render() {
        return (
            <div>
                {/* 子组件接收到数据：  */}
                Hello, {this.props.name},this Child.
            </div>
        )
    }
}
export default Child
```

### 子组件 -> 父组件

利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数。

```js
// Parent.js
// 提供回调函数给子组件，接收子组件数据
class Parent extends React.Component {

    getChildMsg = (msg) => {
        console.log('接收到子组件数据', msg)
        document.querySelector('div').innerHTML = msg
    }

    render() {
        return (
            <div>
                
                {/* 传递数据给子组件 */}
                <Child getChildMsg={this.getChildMsg}/>
            </div>
        )
    }
}
export default Parent

// Child.js
// 传输给父组件数据
class Child extends React.Component {

    state = {
        msg: 'Hello World!'
    }

    handlerClick = () => {
        this.props.getChildMsg(this.state.msg)
    }

    render() {
        return (
            <div onClick={this.handlerClick}>
                {/* 子组件接收到数据：  */}
                Hello, this Child.
            </div>
        )
    }
}
export default Child
```

### 兄弟组件

将共享状态提升到最近的公共父组件中，由公共父组件管理。由公共组件提供共享状态和操作共享状态的方法。

子组件只需通过 props 接收状态或操作状态的方法。

## Context

组件之间传递数据，当层次较多时，使用 props 一层层组件往下传递的方式比较繁琐。

使用 Context 跨组件传递数据。

Context 提供了一个局部的全局作用域。

调用 React. createContext() 创建 Provider（提供数据）和 Consumer（消费数据）两个组件。

---

方式一：在同一个 js 文件下，保证使用同一个 React.createContext 创建的 Provider 和 Consumer.

```jsx
// Contenxt 传递数据 方式1
const { Provider, Consumer } = React.createContext({
    // default value
    value: "defaultValue"
})

class Parent extends React.Component {

    render() {
        return (
            <Provider value={"lingyuan"}>
                <div>
                    this Parent 
                    <LocalChild />
                </div>
            </Provider>
        )
    }
}

class LocalChild extends React.Component {
    render() {
        return (
            <Consumer>
                {(value) => {
                    console.log(value)
                    return (
                        <div>
                            this LocalChild , 接收数据：{value}
                        </div>
                    );
                }}
            </Consumer>
        )
    }
}
export default Parent
```

---

方式二：新建一个 context.js 文件，共享 Provider 和 Consumer.

```jsx
// context.js
import { createContext } from 'react'

// Provider,Consumer 来源于同一个 createContext()
const {Provider,Consumer} = createContext({
    name: 'ly',
    age: 22
});

export {
    Provider,
    Consumer
}

// Parent.js
import { Provider } from "./context";
class Parent extends React.Component {
    obj = {
        name: "lingyuan",
        msg: "hhh"
    }
    render() {
        return (
            <Provider value={this.obj}>
                <div>
                    this Parent 
                    <Child />
                </div>
            </Provider>
        )
    }
}
export default Parent

// Child.js
import { Consumer } from "./context";
class Child extends React.Component {
    render() {
        return (
            <Consumer>
                {(value) => {
                    console.log(value)
                    return (
                        <div>
                            this Child , 接收数据：{value.name} , {value.msg}
                        </div>
                    );
                }}
            </Consumer>
        )
    }
}
export default Child
```

## props进阶

### children 属性

表示组件标签的子节点，当组件标签有子节点时，props 就会有该属性。

值可以是任意值（文本、React元素、组件，函数）。

```jsx
<ComponentsPlus>
    <div>子节点</div>
</ComponentsPlus>

// children 属性
class ComponentsPlus extends React.Component {
    render() {
        return (
            <div>
                {/* 获取子节点 */}
                {this.props.children}<br/>
            </div>
        )
    }
}
```

### 校验

由于 props 是外部传入的，无法保证组件使用者传入格式的数据，如果数据格式不对，可能导致组件内部报错，而组件的使用者不知道错误原因。

在创建组件的时候，就指定 props 的类型、格式等，捕获使用组件时因为 props 导致的错误，给出明确的错误提示，增加组件的健壮性。

使用命令 `npm i prop-types` 安装 prop-types 包。

```jsx
// ComponentsPlus.js
// 导入 prop-types
import PropTypes from 'prop-types';

class ComponentsPlus extends React.Component {
    render() {
        return (
            <div>
                {this.props.name}<br/>
            </div>
        )
    }
}
// 校验 props 属性 组件名.propTypes
ComponentsPlus.propTypes = {
    name: PropTypes.string
}
export default ComponentsPlus;

// index.js
<ComponentsPlus name={this.obj}/> // error type error
<ComponentsPlus name="lingyuan"/> // success
```

约束规则：

- 常见类型：array、bool、func、number、object、string.
- React元素类型：element.
- 必填项：isRequired.
- 特定结构的对象：shape({ }).

### 默认值

给 props 设置默认值，在未传入 props 时生效。

```js
// 组件名.defaultProps
ComponentsPlus.defaultProps = {
    name: 'defaultName'
}
```

## 组件生命周期

生命周期指组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程。

每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数。

只有类组件才有生命周期。

### 创建时

也称挂载阶段，在组件创建时执行。

执行顺序：

1. constructor 钩子函数：创建组件时最先执行，初始化 state ，为事件处理程序绑定 this.
2. render 钩子函数：每次渲染组件时触发，渲染 UI.
3. componentDidMount 钩子函数：组件挂载完成 DOM 渲染后触发，发送网络请求，执行DOM 操作。

### 更新时

也称更新阶段，在 setState()，forceUpdate()，组件接收到新的 props 以上任意一种发生变化，组件就会重新渲染。

执行顺序：

1. render.
2. componentDidMount.

### 卸载时

也称卸载阶段，组件从页面中消失时执行。

componentWillUnmount 钩子函数：执行清理工作。

## 组件复用

如果两个组件中的部分功能相似或相同，想要复用相似的功能，复用 state 和操作 state 的方法。

两种实现方式：render props模式、高阶组件（HOC）。

这不是新的 API，而是利用 React 自身特点的编码技巧，演化而成的固定模式。

### render-props

render-props 是一种设计模式，思想是将要复用的 state 和操作 state 的方法封装到一个组件中并对外暴露（子组件向父组件传递数据）。

在使用组件时，添加一个值为函数的prop，通过函数参数来获取，使用该函数的返回值作为要渲染的 UI 内容。

```jsx
import React from "react";
import PropTypes from 'prop-types';
class Mouse extends React.Component{
    // 初始化 state
    state = {
        x: '0',
        y: '0'
    }
    // 处理 setState 的函数
    handler = (e) => {
        // console.log(e);
        this.setState({
            x: e.screenX,
            y: e.screenY
        })
    }
    // 组件卸载时，解除事件绑定
    componentWillUnmount() {
        window.removeEventListener('mousemove', this.handler)
    }
    render(){
        // 对外暴露组件状态和操作组件状态的方法
        return this.props.render(this.state, this.handler)
    }
}
// 校验 props.render 类型为函数，不要求参数名一定为 render.
Mouse.propTypes = {
    render: PropTypes.func.isRequired
}
export default Mouse;

// 使用组件
<Mouse render={(state, handler) => <p onMouseMove={handler}>鼠标当前位置 {state.x} {state.y}</p>}/>
```

推荐使用 children 代替 render 属性。

```jsx
import React from "react";
import PropTypes from 'prop-types';
class Mouse extends React.Component{
    state = {x: '0',y: '0'}
    handler = (e) => {
        this.setState({
            x: e.screenX,
            y: e.screenY
        })
    }
    render(){
        // 推荐使用 children 代替 render 属性
        return this.props.children(this.state, this.handler)
    }
    // 组件卸载时，解除事件绑定
    componentWillUnmount() {
        window.removeEventListener('mousemove', this.handler)
    }
}
Mouse.propTypes = {
    children: PropTypes.func.isRequired
}
export default Mouse;
// 使用组件
<Mouse>
    {(state, handler) => <div style={{width: '2560px', height: '1660px'}} onMouseMove={handler}>鼠标当前位置 {state.x} {state.y}</div>}
</Mouse>
```

### 高阶组件

高阶组件（HOC，Higher-Order Component）是一个函数，接收要包装的组件，返回增强后的组件。

高阶组件内部创建一个类组件，在类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件 WrappedComponent.

